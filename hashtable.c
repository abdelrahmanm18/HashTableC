#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int (*HashFunction) (void* key, int capacity);
typedef int (*ComapreFunction) (void* a, void* b);

typedef struct ht_item{
    void* key;
    void* value;
    struct ht_item* next;
}ht_item;



typedef struct
{   
    //buckets here is a pointer to an array of pointers
    //Each of those pointers points to a ht_item struct

    /*
    buckets â”€â”€â–º  ptr â”€â”€â–º ht_item { key: "eg", value: "egypt" }
               ptr â”€â”€â–º ht_item { key: "fr", value: "france" }
               ptr â”€â”€â–º NULL
    */
    ht_item** buckets;       
    int initialCapacity;
    int capacity;
    int size;
    HashFunction hashfunction;
    ComapreFunction comparefunction;
}hashtable;


//this is a generic hashfunction signatures
//the user will provide a hash function based on the key type



hashtable createHashTable(HashFunction hashfunction, ComapreFunction comparefunction){
   hashtable table;
   table.size = 0;
   table.initialCapacity = 100;
   table.capacity = table.initialCapacity;
   table.buckets = malloc(sizeof(ht_item*) * table.initialCapacity);
   table.hashfunction = hashfunction;
   table.comparefunction = comparefunction;

   if(table.buckets == NULL){
    printf("Memory allocation failed\n");
    exit(1);
   }

      for(int i = 0; i < table.capacity; i++) {
       table.buckets[i] = NULL;
   }

   return table;
}

//helper methods for hashing and comparing keys

int stringHash(void* key, int capacity){
    int hash = 0;
    char* k =(char*)key;
    for (int i = 0; k[i] != '\0'; i++) {
    hash = (hash * 31 + k[i]) % capacity;
    }
    return hash;
}

int intHash(void* key, int capacity){
    //(int *) --> we tell the compiler treat this as a pointer to an int instead of pointing to unknown type
    // then deferencing to int value
    int k = *(int*)key;
    return k % capacity;
}

int intCompare(void* a, void* b){
    return *(int*)a != *(int*)b;
}

int stringCompare(void* a, void* b){
    return strcmp((char*) a, (char*)b);
}


void put(hashtable* table, void* key, void* value){
    int index = table->hashfunction(key , table->capacity);
    ht_item* current = table->buckets[index];
    while(current != NULL){
        if(table->comparefunction(current->key,key) == 0){
            current->value = value;
            return;
        }
        current = current->next;
    }

    ht_item* item = malloc(sizeof(ht_item));
    item->key = key;
    item->value = value;
    item->next = table->buckets[index];
    table->buckets[index] = item;
    table->size++;
}


void* get(hashtable* table, void* key){
    int index = table->hashfunction(key, table->capacity);
    if(table->size == 0) return NULL;

    ht_item* current = table->buckets[index];

    while(current != NULL){
        if(table->comparefunction(current->key, key) == 0){
            return current->value;
        }
        
        current = current->next;
    }

    return NULL;
}


void* getOrDefault(hashtable* table, void* key, void* defaultValue){
    void* item = get(table, key);
    if(item == NULL){
        return defaultValue;
    }
    return item;
}

int size(hashtable* table){
    return table->size;
}


void clear(hashtable* table){
    for(int i = 0; i < table->capacity; i++){
        ht_item* current = table->buckets[i];
        while(current != NULL){
            ht_item* deleted = current;
            current = current->next;
            free(deleted);
        }
        table->buckets[i] = NULL;

    }

    free(table->buckets);
    table->buckets = NULL;
    table->size = 0;
    table->capacity = table->initialCapacity;

}

void test_hashtable_basic() {

    //test cases generated by ChatGpt to use the hashtable
    hashtable table = createHashTable(stringHash, stringCompare);

    printf("ğŸ”§ Inserting keys...\n");
    put(&table, "name", "Alice");
    put(&table, "age", "25");
    put(&table, "city", "Cairo");
    put(&table, "job", "Engineer");

    printf("ğŸ” Testing get()...\n");
    printf("name: %s\n", (char*)get(&table, "name"));     // Expected: Alice
    printf("age: %s\n", (char*)get(&table, "age"));       // Expected: 25
    printf("city: %s\n", (char*)get(&table, "city"));     // Expected: Cairo
    printf("job: %s\n", (char*)get(&table, "job"));       // Expected: Engineer
    printf("unknown: %s\n", (char*)get(&table, "salary")); // Expected: (null)

    printf("ğŸ›  Testing getOrDefault()...\n");
    char* defaultValue = "N/A";
    printf("salary: %s\n", (char*)getOrDefault(&table, "salary", defaultValue)); // Inserts "salary"
    printf("salary (after): %s\n", (char*)get(&table, "salary"));                // Expected: N/A

    printf("ğŸ“Š Final size: %d (should be 4)\n", size(&table));

    printf("ğŸ§¹ Clearing table...\n");
    clear(&table);
}   

void test_int_keys() {
    printf("\nğŸ”¢ Testing int keys:\n");

    hashtable table = createHashTable(intHash, intCompare);

    int key1 = 10, key2 = 20, key3 = 110;  // key3 will likely collide with key1 if capacity is 100

    put(&table, &key1, "ten");
    put(&table, &key2, "twenty");
    put(&table, &key3, "one hundred ten");

    printf("Key 10: %s\n", (char*)get(&table, &key1));     // Expected: ten
    printf("Key 20: %s\n", (char*)get(&table, &key2));     // Expected: twenty
    printf("Key 110: %s\n", (char*)get(&table, &key3));    // Expected: one hundred ten

    printf("ğŸ“ Size: %d (should be 3)\n", size(&table));

    clear(&table);
}

void test_collisions() {
    printf("\nğŸ¤ Testing collisions:\n");

    hashtable table = createHashTable(stringHash, stringCompare);

    // These strings are designed to likely cause collisions due to simple hash
    put(&table, "ab", "first");
    put(&table, "ba", "second"); // same letters, might hash similarly
    put(&table, "c", "third");

    printf("ab: %s\n", (char*)get(&table, "ab"));   // Expected: first
    printf("ba: %s\n", (char*)get(&table, "ba"));   // Expected: second
    printf("c: %s\n", (char*)get(&table, "c"));     // Expected: third

    printf("ğŸ“ Size: %d (should be 3)\n", size(&table));

    clear(&table);
}

void test_overwrite() {
    printf("\nâœï¸ Testing overwrite:\n");

    hashtable table = createHashTable(stringHash, stringCompare);

    put(&table, "language", "C");
    put(&table, "language", "C++");  // overwrite previous value

    printf("language: %s\n", (char*)get(&table, "language"));  // Expected: C++

    printf("ğŸ“ Size: %d (should be 1)\n", size(&table));

    clear(&table);
}

void test_clear() {
    printf("\nğŸ§¹ Testing clear:\n");

    hashtable table = createHashTable(stringHash, stringCompare);

    put(&table, "a", "1");
    put(&table, "b", "2");
    put(&table, "c", "3");

    clear(&table);

    printf("Size after clear: %d\n", size(&table));                 // Expected: 0
    printf("a: %s\n", (char*)get(&table, "a"));                     // Expected: (null)
}





int main() {
    test_hashtable_basic();
    test_int_keys();
    test_collisions();
    test_overwrite();
    test_clear();
    return 0;
}